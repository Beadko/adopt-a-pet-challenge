{"ast":null,"code":"import _toConsumableArray from \"/Users/bea/Desktop/DevProject/adopt-a-pet-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/Users/bea/Desktop/DevProject/adopt-a-pet-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/bea/Desktop/DevProject/adopt-a-pet-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/bea/Desktop/DevProject/adopt-a-pet-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/Users/bea/Desktop/DevProject/adopt-a-pet-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/bea/Desktop/DevProject/adopt-a-pet-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nexport { i as context } from './index-deps.js';\nimport { c as createCommonjsModule, a as commonjsGlobal, l as lib$2, j as jsonParse, i as isNodeProcess } from './fetch-deps.js';\nimport { _ as __awaiter, g as getPublicUrlFromRequest, p as parseBody, N as NetworkError } from './RequestHandler-deps.js';\nexport { R as RequestHandler, b as compose, c as createResponseComposition, a as defaultContext, d as defaultResponse, m as matchRequestUrl, r as response } from './RequestHandler-deps.js';\nimport { p as parseGraphQLRequest, G as GraphQLHandler } from './graphql-deps.js';\nexport { G as GraphQLHandler, g as graphql, a as graphqlContext } from './graphql-deps.js';\nimport { R as RestHandler, i as isStringEqual } from './rest-deps.js';\nexport { a as RESTMethods, R as RestHandler, r as rest, b as restContext } from './rest-deps.js';\nimport { p as parse_1$1 } from './xml-deps.js';\nimport { m as mergeRight } from './errors-deps.js'; // Copyright Joyent, Inc. and other Node contributors.\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\n\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\nvar events = EventEmitter;\nvar once_1 = once; // Backwards-compat with node 0.10.x\n\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function get() {\n    return defaultMaxListeners;\n  },\n  set: function set(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}; // Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n\n\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    } // At least give some kind of context to the user\n\n\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      ReflectApply(listeners[i], this, args);\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n\n      events = target._events;\n    }\n\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    } // Check for listener leak\n\n\n    m = _getMaxListeners(target);\n\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true; // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n}; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n\n    return this;\n  } // emit removeListener for all listeners on all events\n\n\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) {\n    list[index] = list[index + 1];\n  }\n\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n\n      resolve([].slice.call(arguments));\n    }\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\nevents.once = once_1;\nvar StrictEventEmitter_1 = createCommonjsModule(function (module, exports) {\n  var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {\n    var _extendStatics = function extendStatics(d, b) {\n      _extendStatics = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n      } || function (d, b) {\n        for (var p in b) {\n          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        }\n      };\n\n      return _extendStatics(d, b);\n    };\n\n    return function (d, b) {\n      _extendStatics(d, b);\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n  }();\n\n  var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n      s += arguments[i].length;\n    }\n\n    for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n        r[k] = a[j];\n      }\n    }\n\n    return r;\n  };\n\n  exports.__esModule = true;\n  exports.StrictEventEmitter = void 0;\n\n  var StrictEventEmitter =\n  /** @class */\n  function (_super) {\n    __extends(StrictEventEmitter, _super);\n\n    function StrictEventEmitter() {\n      return _super.call(this) || this;\n    }\n\n    StrictEventEmitter.prototype.on = function (event, listener) {\n      return _super.prototype.on.call(this, event.toString(), listener);\n    };\n\n    StrictEventEmitter.prototype.once = function (event, listener) {\n      return _super.prototype.on.call(this, event.toString(), listener);\n    };\n\n    StrictEventEmitter.prototype.off = function (event, listener) {\n      return _super.prototype.off.call(this, event.toString(), listener);\n    };\n\n    StrictEventEmitter.prototype.emit = function (event) {\n      var data = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        data[_i - 1] = arguments[_i];\n      }\n\n      return _super.prototype.emit.apply(this, __spreadArrays([event.toString()], data));\n    };\n\n    StrictEventEmitter.prototype.addListener = function (event, listener) {\n      return _super.prototype.addListener.call(this, event.toString(), listener);\n    };\n\n    StrictEventEmitter.prototype.removeListener = function (event, listener) {\n      return _super.prototype.removeListener.call(this, event.toString(), listener);\n    };\n\n    return StrictEventEmitter;\n  }(events.EventEmitter);\n\n  exports.StrictEventEmitter = StrictEventEmitter;\n});\nvar lib = createCommonjsModule(function (module, exports) {\n  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    });\n  } : function (o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n  });\n\n  exports.__esModule = true;\n  exports.StrictEventEmitter = void 0;\n\n  __createBinding(exports, StrictEventEmitter_1, \"StrictEventEmitter\");\n});\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * cosnt [error, data] = await until(() => asyncAction())\n */\n\nvar until_1 = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(promise) {\n    var data;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return promise().catch(function (error) {\n              throw error;\n            });\n\n          case 3:\n            data = _context.sent;\n            return _context.abrupt(\"return\", [null, data]);\n\n          case 7:\n            _context.prev = 7;\n            _context.t0 = _context[\"catch\"](0);\n            return _context.abrupt(\"return\", [_context.t0, null]);\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 7]]);\n  }));\n\n  return function until_1(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar until = /*#__PURE__*/Object.defineProperty({\n  until: until_1\n}, '__esModule', {\n  value: true\n});\nvar until$1 = until.until;\n/**\r\n * Attempts to resolve a Service Worker instance from a given registration,\r\n * regardless of its state (active, installing, waiting).\r\n */\n\nvar getWorkerByRegistration = function getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  var allStates = [registration.active, registration.installing, registration.waiting];\n  var existingStates = allStates.filter(Boolean);\n  var mockWorker = existingStates.find(function (worker) {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n};\n/**\r\n * Returns an absolute Service Worker URL based on the given\r\n * relative URL (known during the registration).\r\n */\n\n\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n}\n/**\r\n * Returns an active Service Worker instance.\r\n * When not found, registers a new Service Worker.\r\n */\n\n\nvar getWorkerInstance = function getWorkerInstance(url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var absoluteWorkerUrl, mockRegistrations, _mockRegistrations, existingRegistration, _yield$until$, _yield$until$2, error, instance, isWorkerMissing, scopeUrl;\n\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // Resolve the absolute Service Worker URL.\n            absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n            _context3.next = 3;\n            return navigator.serviceWorker.getRegistrations().then(function (registrations) {\n              return registrations.filter(function (registration) {\n                return getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker);\n              });\n            });\n\n          case 3:\n            mockRegistrations = _context3.sent;\n\n            if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n              // Reload the page when it has associated workers, but no active controller.\n              // The absence of a controller can mean either:\n              // - page has no Service Worker associated with it\n              // - page has been hard-reloaded and its workers won't be used until the next reload.\n              // Since we've checked that there are registrations associated with this page,\n              // at this point we are sure it's hard reload that falls into this clause.\n              location.reload();\n            }\n\n            _mockRegistrations = _slicedToArray(mockRegistrations, 1), existingRegistration = _mockRegistrations[0];\n\n            if (!existingRegistration) {\n              _context3.next = 8;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", existingRegistration.update().then(function () {\n              return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n            }));\n\n          case 8:\n            _context3.next = 10;\n            return until$1(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                var registration;\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return navigator.serviceWorker.register(url, options);\n\n                      case 2:\n                        registration = _context2.sent;\n                        return _context2.abrupt(\"return\", [// Compare existing worker registration by its worker URL,\n                        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n                        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration]);\n\n                      case 4:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n            });\n\n          case 10:\n            _yield$until$ = _context3.sent;\n            _yield$until$2 = _slicedToArray(_yield$until$, 2);\n            error = _yield$until$2[0];\n            instance = _yield$until$2[1];\n\n            if (!error) {\n              _context3.next = 20;\n              break;\n            }\n\n            isWorkerMissing = error.message.includes('(404)'); // Produce a custom error message when given a non-existing Service Worker url.\n            // Suggest developers to check their setup.\n\n            if (!isWorkerMissing) {\n              _context3.next = 19;\n              break;\n            }\n\n            scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || '/', location.href);\n            throw new Error(\"[MSW] Failed to register a Service Worker for scope ('\".concat(scopeUrl.href, \"') with script ('\").concat(absoluteWorkerUrl, \"'): Service Worker script does not exist at the given path.\\n\\nDid you forget to run \\\"npx msw init <PUBLIC_DIR>\\\"?\\n\\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init\"));\n\n          case 19:\n            throw new Error(\"[MSW] Failed to register a Service Worker:\\n\\n\".concat(error.message));\n\n          case 20:\n            return _context3.abrupt(\"return\", instance);\n\n          case 21:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n};\n\nvar activateMocking = function activateMocking(context, options) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            context.workerChannel.send('MOCK_ACTIVATE');\n            return _context4.abrupt(\"return\", context.events.once('MOCKING_ENABLED').then(function () {\n              if (!(options === null || options === void 0 ? void 0 : options.quiet)) {\n                console.groupCollapsed('%c[MSW] Mocking enabled.', 'color:orangered;font-weight:bold;');\n                console.log('%cDocumentation: %chttps://mswjs.io/docs', 'font-weight:bold', 'font-weight:normal');\n                console.log('Found an issue? https://github.com/mswjs/msw/issues');\n                console.groupEnd();\n              }\n            }));\n\n          case 2:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n};\n/**\r\n * Creates a communication channel between the client\r\n * and the Service Worker associated with the given event.\r\n */\n\n\nvar createBroadcastChannel = function createBroadcastChannel(event) {\n  var port = event.ports[0];\n  return {\n    /**\r\n     * Sends a text message to the connected Service Worker.\r\n     */\n    send: function send(message) {\n      if (port) {\n        port.postMessage(message);\n      }\n    }\n  };\n};\n/**\r\n * Returns a mocked response for a given request using following request handlers.\r\n */\n\n\nvar getResponse = function getResponse(request, handlers) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n    var relevantHandlers, result;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            relevantHandlers = handlers.filter(function (handler) {\n              return handler.test(request);\n            });\n\n            if (!(relevantHandlers.length === 0)) {\n              _context6.next = 3;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", {\n              handler: undefined,\n              response: undefined\n            });\n\n          case 3:\n            _context6.next = 5;\n            return relevantHandlers.reduce(function (acc, handler) {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                var previousResults, result;\n                return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                        _context5.next = 2;\n                        return acc;\n\n                      case 2:\n                        previousResults = _context5.sent;\n\n                        if (!(previousResults === null || previousResults === void 0 ? void 0 : previousResults.response)) {\n                          _context5.next = 5;\n                          break;\n                        }\n\n                        return _context5.abrupt(\"return\", acc);\n\n                      case 5:\n                        _context5.next = 7;\n                        return handler.run(request);\n\n                      case 7:\n                        result = _context5.sent;\n\n                        if (!(result === null || result.handler.shouldSkip)) {\n                          _context5.next = 10;\n                          break;\n                        }\n\n                        return _context5.abrupt(\"return\", null);\n\n                      case 10:\n                        if (result.response) {\n                          _context5.next = 12;\n                          break;\n                        }\n\n                        return _context5.abrupt(\"return\", {\n                          request: result.request,\n                          handler: result.handler,\n                          response: undefined,\n                          parsedResult: result.parsedResult\n                        });\n\n                      case 12:\n                        if (result.response.once) {\n                          handler.markAsSkipped(true);\n                        }\n\n                        return _context5.abrupt(\"return\", result);\n\n                      case 14:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5);\n              }));\n            }, Promise.resolve(null));\n\n          case 5:\n            result = _context6.sent;\n\n            if (result) {\n              _context6.next = 8;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", {\n              handler: undefined,\n              response: undefined\n            });\n\n          case 8:\n            return _context6.abrupt(\"return\", {\n              handler: result.handler,\n              publicRequest: result.request,\n              parsedRequest: result.parsedResult,\n              response: result.response\n            });\n\n          case 9:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n};\n\nvar jsLevenshtein = function () {\n  function _min(d0, d1, d2, bx, ay) {\n    return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;\n  }\n\n  return function (a, b) {\n    if (a === b) {\n      return 0;\n    }\n\n    if (a.length > b.length) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    var la = a.length;\n    var lb = b.length;\n\n    while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n      la--;\n      lb--;\n    }\n\n    var offset = 0;\n\n    while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n      offset++;\n    }\n\n    la -= offset;\n    lb -= offset;\n\n    if (la === 0 || lb < 3) {\n      return lb;\n    }\n\n    var x = 0;\n    var y;\n    var d0;\n    var d1;\n    var d2;\n    var d3;\n    var dd;\n    var dy;\n    var ay;\n    var bx0;\n    var bx1;\n    var bx2;\n    var bx3;\n    var vector = [];\n\n    for (y = 0; y < la; y++) {\n      vector.push(y + 1);\n      vector.push(a.charCodeAt(offset + y));\n    }\n\n    var len = vector.length - 1;\n\n    for (; x < lb - 3;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      bx1 = b.charCodeAt(offset + (d1 = x + 1));\n      bx2 = b.charCodeAt(offset + (d2 = x + 2));\n      bx3 = b.charCodeAt(offset + (d3 = x + 3));\n      dd = x += 4;\n\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        ay = vector[y + 1];\n        d0 = _min(dy, d0, d1, bx0, ay);\n        d1 = _min(d0, d1, d2, bx1, ay);\n        d2 = _min(d1, d2, d3, bx2, ay);\n        dd = _min(d2, d3, dd, bx3, ay);\n        vector[y] = dd;\n        d3 = d2;\n        d2 = d1;\n        d1 = d0;\n        d0 = dy;\n      }\n    }\n\n    for (; x < lb;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      dd = ++x;\n\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n        d0 = dy;\n      }\n    }\n\n    return dd;\n  };\n}();\n\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\n\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(function (groups, handler) {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\n\nfunction getScoreForRestHandler() {\n  return function (request, handler) {\n    var _handler$info = handler.info,\n        mask = _handler$info.mask,\n        method = _handler$info.method;\n\n    if (mask instanceof RegExp) {\n      return Infinity;\n    }\n\n    var hasSameMethod = isStringEqual(request.method, method); // Always treat a handler with the same method as a more similar one.\n\n    var methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    var requestPublicUrl = getPublicUrlFromRequest(request);\n    var score = jsLevenshtein(requestPublicUrl, mask);\n    return score - methodScoreDelta;\n  };\n}\n\nfunction getScoreForGraphQLHandler(parsedQuery) {\n  return function (_, handler) {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity;\n    }\n\n    var _handler$info2 = handler.info,\n        operationType = _handler$info2.operationType,\n        operationName = _handler$info2.operationName;\n    var hasSameOperationType = parsedQuery.operationType === operationType; // Always treat a handler with the same operation type as a more similar one.\n\n    var operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    var score = jsLevenshtein(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\n\nfunction getSuggestedHandler(request, handlers, getScore) {\n  var suggestedHandlers = handlers.reduce(function (acc, handler) {\n    var score = getScore(request, handler);\n    return acc.concat([[score, handler]]);\n  }, []).sort(function (_ref2, _ref3) {\n    var _ref4 = _slicedToArray(_ref2, 1),\n        leftScore = _ref4[0];\n\n    var _ref5 = _slicedToArray(_ref3, 1),\n        rightScore = _ref5[0];\n\n    return leftScore - rightScore;\n  }).filter(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 1),\n        score = _ref7[0];\n\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(function (_ref8) {\n    var _ref9 = _slicedToArray(_ref8, 2),\n        handler = _ref9[1];\n\n    return handler;\n  });\n  return suggestedHandlers;\n}\n\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return \"Did you mean to request one of the following resources instead?\\n\\n\".concat(handlers.map(function (handler) {\n      return \"  \\u2022 \".concat(handler.info.header);\n    }).join('\\n'));\n  }\n\n  return \"Did you mean to request \\\"\".concat(handlers[0].info.header, \"\\\" instead?\");\n}\n\nfunction onUnhandledRequest(request, handlers) {\n  var strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'bypass';\n\n  if (typeof strategy === 'function') {\n    strategy(request);\n    return;\n  }\n\n  var parsedGraphQLQuery = parseGraphQLRequest(request);\n  var handlerGroups = groupHandlersByType(handlers);\n  var relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n  var suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getScoreForGraphQLHandler(parsedGraphQLQuery) : getScoreForRestHandler());\n  var handlerSuggestion = suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : '';\n  var publicUrl = getPublicUrlFromRequest(request);\n  var requestHeader = parsedGraphQLQuery ? \"\".concat(parsedGraphQLQuery.operationType, \" \").concat(parsedGraphQLQuery.operationName, \" (\").concat(request.method, \" \").concat(publicUrl, \")\") : \"\".concat(request.method, \" \").concat(publicUrl);\n  var messageTemplate = [\"captured a request without a matching request handler:\", \"  \\u2022 \".concat(requestHeader), handlerSuggestion, \"If you still wish to intercept this unhandled request, please create a request handler for it.\\nRead more: https://mswjs.io/docs/getting-started/mocks\"].filter(Boolean);\n  var message = messageTemplate.join('\\n\\n');\n\n  switch (strategy) {\n    case 'error':\n      {\n        console.error(\"[MSW] Error: \".concat(message));\n        break;\n      }\n\n    case 'warn':\n      {\n        console.warn(\"[MSW] Warning: \".concat(message));\n        break;\n      }\n\n    default:\n      return;\n  }\n}\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n  var nameValue = parts.shift().split(\"=\");\n  var name = nameValue.shift();\n  var value = nameValue.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n\n  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\"set-cookie-parser encountered an error while decoding a cookie with value '\" + value + \"'. Set options.decodeValues to false to disable this feature.\", e);\n  }\n\n  var cookie = {\n    name: name,\n    // grab everything before the first =\n    value: value\n  };\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n  return cookie;\n}\n\nfunction parse(input, options) {\n  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers && input.headers[\"set-cookie\"]) {\n    // fast-path for node.js (which automatically normalizes header names to lower-case\n    input = input.headers[\"set-cookie\"];\n  } else if (input.headers) {\n    // slow-path for other environments - see #25\n    var sch = input.headers[Object.keys(input.headers).find(function (key) {\n      return key.toLowerCase() === \"set-cookie\";\n    })]; // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n\n    if (!sch && input.headers.cookie && !options.silent) {\n      console.warn(\"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\");\n    }\n\n    input = sch;\n  }\n\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\n\n\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        } // currently special character\n\n\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true; // pos is inside the next cookie, so back up and return it.\n\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nvar setCookie = parse;\nvar parse_1 = parse;\nvar parseString_1 = parseString;\nvar splitCookiesString_1 = splitCookiesString;\nsetCookie.parse = parse_1;\nsetCookie.parseString = parseString_1;\nsetCookie.splitCookiesString = splitCookiesString_1;\nvar CookieStore_1 = createCommonjsModule(function (module, exports) {\n  var __rest = commonjsGlobal && commonjsGlobal.__rest || function (s, e) {\n    var t = {};\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    }\n\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n  };\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.PERSISTENCY_KEY = void 0;\n  exports.PERSISTENCY_KEY = 'MSW_COOKIE_STORE';\n\n  var CookieStore = /*#__PURE__*/function () {\n    function CookieStore() {\n      _classCallCheck(this, CookieStore);\n\n      this.store = new Map();\n      this.supportsPersistency = typeof window !== 'undefined';\n    }\n    /**\n     * Sets the given request cookies into the store.\n     * Respects the `request.credentials` policy.\n     */\n\n\n    _createClass(CookieStore, [{\n      key: \"add\",\n      value: function add(request, response) {\n        var _this = this;\n\n        if (request.credentials === 'omit') {\n          return;\n        }\n\n        var requestUrl = new URL(request.url);\n        var responseCookies = response.headers.get('set-cookie');\n\n        if (!responseCookies) {\n          return;\n        }\n\n        var now = Date.now();\n        var parsedResponseCookies = setCookie.parse(responseCookies).map(function (_a) {\n          var maxAge = _a.maxAge,\n              cookie = __rest(_a, [\"maxAge\"]);\n\n          return Object.assign(Object.assign({}, cookie), {\n            expires: maxAge === undefined ? cookie.expires : new Date(now + maxAge * 1000),\n            maxAge: maxAge\n          });\n        }).filter(function (_ref10) {\n          var expires = _ref10.expires;\n          return expires === undefined || expires.getTime() > now;\n        });\n        var prevCookies = this.store.get(requestUrl.origin) || new Map();\n        parsedResponseCookies.forEach(function (cookie) {\n          _this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie));\n        });\n      }\n      /**\n       * Returns cookies relevant to the given request\n       * and its `request.credentials` policy.\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(request) {\n        this.deleteExpiredCookies();\n        var requestUrl = new URL(request.url);\n        var originCookies = this.store.get(requestUrl.origin) || new Map();\n\n        switch (request.credentials) {\n          case 'include':\n            {\n              var documentCookies = setCookie.parse(document.cookie);\n              documentCookies.forEach(function (cookie) {\n                originCookies.set(cookie.name, cookie);\n              });\n              return originCookies;\n            }\n\n          case 'same-origin':\n            {\n              return originCookies;\n            }\n\n          default:\n            return new Map();\n        }\n      }\n      /**\n       * Returns a collection of all stored cookies.\n       */\n\n    }, {\n      key: \"getAll\",\n      value: function getAll() {\n        this.deleteExpiredCookies();\n        return this.store;\n      }\n      /**\n       * Deletes all cookies associated with the given request.\n       */\n\n    }, {\n      key: \"deleteAll\",\n      value: function deleteAll(request) {\n        var requestUrl = new URL(request.url);\n        this.store.delete(requestUrl.origin);\n      }\n      /**\n       * Clears the entire cookie store.\n       */\n\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.store.clear();\n      }\n      /**\n       * Hydrates the virtual cookie store from the `localStorage`.\n       */\n\n    }, {\n      key: \"hydrate\",\n      value: function hydrate() {\n        var _this2 = this;\n\n        if (!this.supportsPersistency) {\n          return;\n        }\n\n        var persistedCookies = localStorage.getItem(exports.PERSISTENCY_KEY);\n\n        if (persistedCookies) {\n          try {\n            var parsedCookies = JSON.parse(persistedCookies);\n            parsedCookies.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 2),\n                  origin = _ref12[0],\n                  cookies = _ref12[1];\n\n              _this2.store.set(origin, new Map(cookies.map(function (_a) {\n                var _a2 = _slicedToArray(_a, 2),\n                    token = _a2[0],\n                    _b = _a2[1],\n                    expires = _b.expires,\n                    cookie = __rest(_b, [\"expires\"]);\n\n                return [token, expires === undefined ? cookie : Object.assign(Object.assign({}, cookie), {\n                  expires: new Date(expires)\n                })];\n              })));\n            });\n          } catch (error) {\n            console.warn(\"\\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \\\"\".concat(exports.PERSISTENCY_KEY, \"\\\").\\n\\nStored value:\\n\").concat(localStorage.getItem(exports.PERSISTENCY_KEY), \"\\n\\nThrown exception:\\n\").concat(error, \"\\n\\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.\"));\n            localStorage.removeItem(exports.PERSISTENCY_KEY);\n          }\n        }\n      }\n      /**\n       * Persists the current virtual cookies into the `localStorage`,\n       * so they are available on the next page load.\n       */\n\n    }, {\n      key: \"persist\",\n      value: function persist() {\n        if (!this.supportsPersistency) {\n          return;\n        }\n\n        var serializedCookies = Array.from(this.store.entries()).map(function (_ref13) {\n          var _ref14 = _slicedToArray(_ref13, 2),\n              origin = _ref14[0],\n              cookies = _ref14[1];\n\n          return [origin, Array.from(cookies.entries())];\n        });\n        localStorage.setItem(exports.PERSISTENCY_KEY, JSON.stringify(serializedCookies));\n      }\n    }, {\n      key: \"deleteExpiredCookies\",\n      value: function deleteExpiredCookies() {\n        var _this3 = this;\n\n        var now = Date.now();\n        this.store.forEach(function (originCookies, origin) {\n          originCookies.forEach(function (_ref15) {\n            var expires = _ref15.expires,\n                name = _ref15.name;\n\n            if (expires !== undefined && expires.getTime() <= now) {\n              originCookies.delete(name);\n            }\n          });\n\n          if (originCookies.size === 0) {\n            _this3.store.delete(origin);\n          }\n        });\n      }\n    }]);\n\n    return CookieStore;\n  }();\n\n  exports.default = new CookieStore();\n});\nvar lib$1 = createCommonjsModule(function (module, exports) {\n  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {\n    return mod && mod.__esModule ? mod : {\n      \"default\": mod\n    };\n  };\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.PERSISTENCY_KEY = exports.store = void 0;\n  Object.defineProperty(exports, \"store\", {\n    enumerable: true,\n    get: function get() {\n      return __importDefault(CookieStore_1).default;\n    }\n  });\n  Object.defineProperty(exports, \"PERSISTENCY_KEY\", {\n    enumerable: true,\n    get: function get() {\n      return CookieStore_1.PERSISTENCY_KEY;\n    }\n  });\n});\n\nfunction getAllCookies() {\n  return parse_1$1(document.cookie);\n}\n/**\r\n * Returns relevant document cookies based on the request `credentials` option.\r\n */\n\n\nfunction getRequestCookies(request) {\n  /**\r\n   * @note No cookies persist on the document in Node.js: no document.\r\n   */\n  if (typeof location === 'undefined') {\n    return {};\n  }\n\n  switch (request.credentials) {\n    case 'same-origin':\n      {\n        // Return document cookies only when requested a resource\n        // from the same origin as the current document.\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n\n    case 'include':\n      {\n        // Return all document cookies.\n        return getAllCookies();\n      }\n\n    default:\n      {\n        return {};\n      }\n  }\n}\n\nfunction setRequestCookies(request) {\n  var _a;\n\n  lib$1.store.hydrate();\n  request.cookies = Object.assign(Object.assign({}, getRequestCookies(request)), Array.from((_a = lib$1.store.get(Object.assign(Object.assign({}, request), {\n    url: request.url.toString()\n  }))) === null || _a === void 0 ? void 0 : _a.entries()).reduce(function (cookies, _ref16) {\n    var _ref17 = _slicedToArray(_ref16, 2),\n        name = _ref17[0],\n        value = _ref17[1].value;\n\n    return Object.assign(cookies, _defineProperty({}, name, value));\n  }, {}));\n  request.headers.set('cookie', Object.entries(request.cookies).map(function (_ref18) {\n    var _ref19 = _slicedToArray(_ref18, 2),\n        name = _ref19[0],\n        value = _ref19[1];\n\n    return \"\".concat(name, \"=\").concat(value);\n  }).join('; '));\n}\n/**\r\n * Ensures that an empty GET request body is always represented as `undefined`.\r\n */\n\n\nfunction pruneGetRequestBody(request) {\n  if (request.method && isStringEqual(request.method, 'GET') && request.body === '') {\n    return undefined;\n  }\n\n  return request.body;\n}\n\nfunction parseWorkerRequest(rawRequest) {\n  var request = {\n    id: rawRequest.id,\n    cache: rawRequest.cache,\n    credentials: rawRequest.credentials,\n    method: rawRequest.method,\n    url: new URL(rawRequest.url),\n    referrer: rawRequest.referrer,\n    referrerPolicy: rawRequest.referrerPolicy,\n    redirect: rawRequest.redirect,\n    mode: rawRequest.mode,\n    params: {},\n    cookies: {},\n    integrity: rawRequest.integrity,\n    keepalive: rawRequest.keepalive,\n    destination: rawRequest.destination,\n    body: pruneGetRequestBody(rawRequest),\n    bodyUsed: rawRequest.bodyUsed,\n    headers: new lib$2.Headers(rawRequest.headers)\n  }; // Set document cookies on the request.\n\n  setRequestCookies(request); // Parse the request's body based on the \"Content-Type\" header.\n\n  request.body = parseBody(request.body, request.headers);\n  return request;\n}\n\nfunction readResponseCookies(request, response) {\n  lib$1.store.add(Object.assign(Object.assign({}, request), {\n    url: request.url.toString()\n  }), response);\n  lib$1.store.persist();\n}\n\nvar createRequestListener = function createRequestListener(context, options) {\n  return function (event, message) {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n      var channel, request, _yield$getResponse, response, handler, publicRequest, parsedRequest, responseWithSerializedHeaders;\n\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              channel = createBroadcastChannel(event);\n              _context7.prev = 1;\n              request = parseWorkerRequest(message.payload);\n              context.emitter.emit('request:start', request); // Set document cookies on the request.\n\n              setRequestCookies(request);\n              _context7.next = 7;\n              return getResponse(request, context.requestHandlers);\n\n            case 7:\n              _yield$getResponse = _context7.sent;\n              response = _yield$getResponse.response;\n              handler = _yield$getResponse.handler;\n              publicRequest = _yield$getResponse.publicRequest;\n              parsedRequest = _yield$getResponse.parsedRequest;\n\n              if (handler) {\n                _context7.next = 17;\n                break;\n              }\n\n              onUnhandledRequest(request, context.requestHandlers, options.onUnhandledRequest);\n              context.emitter.emit('request:unhandled', request);\n              context.emitter.emit('request:end', request);\n              return _context7.abrupt(\"return\", channel.send({\n                type: 'MOCK_NOT_FOUND'\n              }));\n\n            case 17:\n              context.emitter.emit('request:match', request); // Handle a scenario when there is a request handler,\n              // but it doesn't return any mocked response.\n\n              if (response) {\n                _context7.next = 22;\n                break;\n              }\n\n              console.warn('[MSW] Expected a mocking resolver function to return a mocked response Object, but got: %s. Original response is going to be used instead.', response);\n              context.emitter.emit('request:end', request);\n              return _context7.abrupt(\"return\", channel.send({\n                type: 'MOCK_NOT_FOUND'\n              }));\n\n            case 22:\n              readResponseCookies(request, response);\n              responseWithSerializedHeaders = Object.assign(Object.assign({}, response), {\n                headers: lib$2.headersToList(response.headers)\n              });\n\n              if (!options.quiet) {\n                setTimeout(function () {\n                  handler.log(publicRequest, responseWithSerializedHeaders, handler, parsedRequest);\n                }, response.delay);\n              }\n\n              context.emitter.emit('request:end', request);\n              channel.send({\n                type: 'MOCK_SUCCESS',\n                payload: responseWithSerializedHeaders\n              });\n              _context7.next = 34;\n              break;\n\n            case 29:\n              _context7.prev = 29;\n              _context7.t0 = _context7[\"catch\"](1);\n\n              if (!(_context7.t0 instanceof NetworkError)) {\n                _context7.next = 33;\n                break;\n              }\n\n              return _context7.abrupt(\"return\", channel.send({\n                type: 'NETWORK_ERROR',\n                payload: {\n                  name: _context7.t0.name,\n                  message: _context7.t0.message\n                }\n              }));\n\n            case 33:\n              // Treat all the other exceptions in a request handler\n              // as unintended, alerting that there is a problem needs fixing.\n              channel.send({\n                type: 'INTERNAL_ERROR',\n                payload: {\n                  status: 500,\n                  body: JSON.stringify({\n                    errorType: _context7.t0.constructor.name,\n                    message: _context7.t0.message,\n                    location: _context7.t0.stack\n                  })\n                }\n              });\n\n            case 34:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[1, 29]]);\n    }));\n  };\n};\n\nfunction requestIntegrityCheck(context, serviceWorker) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n    var _yield$context$events, actualChecksum;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            // Signal Service Worker to report back its integrity\n            context.workerChannel.send('INTEGRITY_CHECK_REQUEST');\n            _context8.next = 3;\n            return context.events.once('INTEGRITY_CHECK_RESPONSE');\n\n          case 3:\n            _yield$context$events = _context8.sent;\n            actualChecksum = _yield$context$events.payload;\n\n            if (!(actualChecksum !== \"82ef9b96d8393b6da34527d1d6e19187\")) {\n              _context8.next = 7;\n              break;\n            }\n\n            throw new Error(\"Currently active Service Worker (\".concat(actualChecksum, \") is behind the latest published one (\", \"82ef9b96d8393b6da34527d1d6e19187\", \").\"));\n\n          case 7:\n            return _context8.abrupt(\"return\", serviceWorker);\n\n          case 8:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n}\n/**\r\n * Intercepts and defers any requests on the page\r\n * until the Service Worker instance is ready.\r\n * Must only be used in a browser.\r\n */\n\n\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  var _this5 = this;\n\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  var originalXhrSend = window.XMLHttpRequest.prototype.send;\n\n  window.XMLHttpRequest.prototype.send = function () {\n    var _this4 = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    until$1(function () {\n      return predicatePromise;\n    }).then(function () {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n\n      _this4.send.apply(_this4, args);\n    });\n  }; // Defer any `fetch` requests until the Service Worker is ready.\n\n\n  var originalFetch = window.fetch;\n\n  window.fetch = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return __awaiter(_this5, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n      var _window;\n\n      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return until$1(function () {\n                return predicatePromise;\n              });\n\n            case 2:\n              window.fetch = originalFetch;\n              return _context9.abrupt(\"return\", (_window = window).fetch.apply(_window, args));\n\n            case 4:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9);\n    }));\n  };\n}\n\nfunction createResponseListener(context) {\n  return function (_, message) {\n    var _a;\n\n    var responseJson = message.payload;\n    /**\r\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\r\n     * That kind of responses cannot be manipulated in JavaScript due\r\n     * to the security considerations.\r\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\r\n     * @see https://github.com/mswjs/msw/issues/529\r\n     */\n\n    if ((_a = responseJson.type) === null || _a === void 0 ? void 0 : _a.includes('opaque')) {\n      return;\n    }\n\n    var response = new Response(responseJson.body || null, responseJson);\n    var isMockedResponse = response.headers.get('x-powered-by') === 'msw';\n\n    if (isMockedResponse) {\n      context.emitter.emit('response:mocked', response, responseJson.requestId);\n    } else {\n      context.emitter.emit('response:bypass', response, responseJson.requestId);\n    }\n  };\n}\n\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'bypass',\n  findWorker: function findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\nvar createStart = function createStart(context) {\n  /**\r\n   * Registers and activates the mock Service Worker.\r\n   */\n  return function start(options) {\n    var _this6 = this;\n\n    var resolvedOptions = mergeRight(DEFAULT_START_OPTIONS, options || {}); // Store the start options in the context so that other methods (like `stop`)\n    // could reference them.\n\n    context.startOptions = resolvedOptions;\n\n    var startWorkerInstance = function startWorkerInstance() {\n      return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var instance, _instance, worker, registration, missingWorkerMessage, _yield$until$3, _yield$until$4, integrityError;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if ('serviceWorker' in navigator) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error(\"[MSW] Failed to register a Service Worker: this browser does not support Service Workers (see https://caniuse.com/serviceworkers), or your application is running on an insecure host (consider using HTTPS for custom hostnames).\");\n\n              case 2:\n                // Remove all previously existing event listeners.\n                // This way none of the listeners persists between Fast refresh\n                // of the application's code.\n                context.events.removeAllListeners(); // Handle requests signaled by the worker.\n\n                context.workerChannel.on('REQUEST', createRequestListener(context, resolvedOptions));\n                context.workerChannel.on('RESPONSE', createResponseListener(context));\n                _context10.next = 7;\n                return getWorkerInstance(resolvedOptions.serviceWorker.url, resolvedOptions.serviceWorker.options, resolvedOptions.findWorker);\n\n              case 7:\n                instance = _context10.sent;\n                _instance = _slicedToArray(instance, 2), worker = _instance[0], registration = _instance[1];\n\n                if (worker) {\n                  _context10.next = 12;\n                  break;\n                }\n\n                missingWorkerMessage = (options === null || options === void 0 ? void 0 : options.findWorker) ? \"[MSW] Failed to locate the Service Worker registration using a custom \\\"findWorker\\\" predicate.\\n\\nPlease ensure that the custom predicate properly locates the Service Worker registration at \\\"\".concat(resolvedOptions.serviceWorker.url, \"\\\".\\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\\n\") : \"[MSW] Failed to locate the Service Worker registration.\\n\\nThis most likely means that the worker script URL \\\"\".concat(resolvedOptions.serviceWorker.url, \"\\\" cannot resolve against the actual public hostname (\").concat(location.host, \"). This may happen if your application runs behind a proxy, or has a dynamic hostname.\\n\\nPlease consider using a custom \\\"serviceWorker.url\\\" option to point to the actual worker script location, or a custom \\\"findWorker\\\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start\");\n                throw new Error(missingWorkerMessage);\n\n              case 12:\n                context.worker = worker;\n                context.registration = registration;\n                context.events.addListener(window, 'beforeunload', function () {\n                  if (worker.state !== 'redundant') {\n                    // Notify the Service Worker that this client has closed.\n                    // Internally, it's similar to disabling the mocking, only\n                    // client close event has a handler that self-terminates\n                    // the Service Worker when there are no open clients.\n                    context.workerChannel.send('CLIENT_CLOSED');\n                  } // Make sure we're always clearing the interval - there are reports that not doing this can\n                  // cause memory leaks in headless browser environments.\n\n\n                  window.clearInterval(context.keepAliveInterval);\n                }); // Check if the active Service Worker is the latest published one\n\n                _context10.next = 17;\n                return until$1(function () {\n                  return requestIntegrityCheck(context, worker);\n                });\n\n              case 17:\n                _yield$until$3 = _context10.sent;\n                _yield$until$4 = _slicedToArray(_yield$until$3, 1);\n                integrityError = _yield$until$4[0];\n\n                if (integrityError) {\n                  console.error(\"[MSW] Detected outdated Service Worker: \".concat(integrityError.message, \"\\n\\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\\n\\n$ npx msw init <PUBLIC_DIR>\\n\\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      \"));\n                } // Signal the Service Worker to enable requests interception\n\n\n                _context10.next = 23;\n                return activateMocking(context, options).catch(function (err) {\n                  throw new Error(\"Failed to enable mocking: \".concat(err === null || err === void 0 ? void 0 : err.message));\n                });\n\n              case 23:\n                context.keepAliveInterval = window.setInterval(function () {\n                  return context.workerChannel.send('KEEPALIVE_REQUEST');\n                }, 5000);\n                return _context10.abrupt(\"return\", registration);\n\n              case 25:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n    };\n\n    var workerRegistration = startWorkerInstance(); // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n\n    if (resolvedOptions.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n\n    return workerRegistration;\n  };\n};\n\nvar createStop = function createStop(context) {\n  /**\r\n   * Signal the Service Worker to disable mocking for this client.\r\n   * Use this an an explicit way to stop the mocking, while preserving\r\n   * the worker-client relation. Does not affect the worker's lifecycle.\r\n   */\n  return function stop() {\n    var _a;\n\n    context.workerChannel.send('MOCK_DEACTIVATE');\n    context.events.removeAllListeners();\n    context.emitter.removeAllListeners();\n    window.clearInterval(context.keepAliveInterval);\n\n    if (!((_a = context.startOptions) === null || _a === void 0 ? void 0 : _a.quiet)) {\n      console.log('%c[MSW] Mocking disabled.', 'color:orangered;font-weight:bold;');\n    }\n  };\n};\n\nfunction _use(currentHandlers) {\n  for (var _len3 = arguments.length, handlers = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    handlers[_key3 - 1] = arguments[_key3];\n  }\n\n  currentHandlers.unshift.apply(currentHandlers, handlers);\n}\n\nfunction _restoreHandlers(handlers) {\n  handlers.forEach(function (handler) {\n    handler.markAsSkipped(false);\n  });\n}\n\nfunction _resetHandlers(initialHandlers) {\n  for (var _len4 = arguments.length, nextHandlers = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    nextHandlers[_key4 - 1] = arguments[_key4];\n  }\n\n  return nextHandlers.length > 0 ? [].concat(nextHandlers) : _toConsumableArray(initialHandlers);\n} // Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\n\n\nvar listeners = [];\n/**\r\n * Creates a new mock Service Worker registration\r\n * with the given request handlers.\r\n * @param {RequestHandler[]} requestHandlers List of request handlers\r\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\r\n */\n\nfunction setupWorker() {\n  for (var _len5 = arguments.length, requestHandlers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    requestHandlers[_key5] = arguments[_key5];\n  }\n\n  requestHandlers.forEach(function (handler) {\n    if (Array.isArray(handler)) throw new Error(\"[MSW] Failed to call \\\"setupWorker\\\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).\");\n  });\n  var context = {\n    startOptions: undefined,\n    worker: null,\n    registration: null,\n    requestHandlers: [].concat(requestHandlers),\n    emitter: new lib.StrictEventEmitter(),\n    workerChannel: {\n      on: function on(eventType, callback) {\n        context.events.addListener(navigator.serviceWorker, 'message', function (event) {\n          // Avoid messages broadcasted from unrelated workers.\n          if (event.source !== context.worker) {\n            return;\n          }\n\n          var message = jsonParse(event.data);\n\n          if (!message) {\n            return;\n          }\n\n          if (message.type === eventType) {\n            callback(event, message);\n          }\n        });\n      },\n      send: function send(type) {\n        var _a;\n\n        (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage(type);\n      }\n    },\n    events: {\n      addListener: function addListener(target, eventType, callback) {\n        target.addEventListener(eventType, callback);\n        listeners.push({\n          eventType: eventType,\n          target: target,\n          callback: callback\n        });\n        return function () {\n          target.removeEventListener(eventType, callback);\n        };\n      },\n      removeAllListeners: function removeAllListeners() {\n        var _iterator = _createForOfIteratorHelper(listeners),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _step.value,\n                target = _step$value.target,\n                eventType = _step$value.eventType,\n                callback = _step$value.callback;\n            target.removeEventListener(eventType, callback);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        listeners = [];\n      },\n      once: function once(eventType) {\n        var bindings = [];\n        return new Promise(function (resolve, reject) {\n          var handleIncomingMessage = function handleIncomingMessage(event) {\n            try {\n              var message = JSON.parse(event.data);\n\n              if (message.type === eventType) {\n                resolve(message);\n              }\n            } catch (error) {\n              reject(error);\n            }\n          };\n\n          bindings.push(context.events.addListener(navigator.serviceWorker, 'message', handleIncomingMessage), context.events.addListener(navigator.serviceWorker, 'messageerror', reject));\n        }).finally(function () {\n          bindings.forEach(function (unbind) {\n            return unbind();\n          });\n        });\n      }\n    }\n  }; // Error when attempting to run this function in a Node.js environment.\n\n  if (isNodeProcess()) {\n    throw new Error('[MSW] Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.');\n  }\n\n  return {\n    start: createStart(context),\n    stop: createStop(context),\n    use: function use() {\n      for (var _len6 = arguments.length, handlers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        handlers[_key6] = arguments[_key6];\n      }\n\n      console.log('adding new handlers', handlers);\n\n      _use.apply(void 0, [context.requestHandlers].concat(handlers));\n    },\n    restoreHandlers: function restoreHandlers() {\n      _restoreHandlers(context.requestHandlers);\n    },\n    resetHandlers: function resetHandlers() {\n      for (var _len7 = arguments.length, nextHandlers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        nextHandlers[_key7] = arguments[_key7];\n      }\n\n      context.requestHandlers = _resetHandlers.apply(void 0, [requestHandlers].concat(nextHandlers));\n    },\n    printHandlers: function printHandlers() {\n      context.requestHandlers.forEach(function (handler) {\n        var _handler$info3 = handler.info,\n            header = _handler$info3.header,\n            callFrame = _handler$info3.callFrame;\n        var pragma = handler.info.hasOwnProperty('operationType') ? '[graphql]' : '[rest]';\n        console.groupCollapsed(\"\".concat(pragma, \" \").concat(header));\n\n        if (callFrame) {\n          console.log(\"Declaration: \".concat(callFrame));\n        }\n\n        console.log('Handler:', handler);\n\n        if (handler instanceof RestHandler) {\n          console.log('Match:', \"https://mswjs.io/repl?path=\".concat(handler.info.mask));\n        }\n\n        console.groupEnd();\n      });\n    },\n    on: function on(eventType, listener) {\n      context.emitter.addListener(eventType, listener);\n    }\n  };\n}\n\nexport { setupWorker };","map":null,"metadata":{},"sourceType":"module"}